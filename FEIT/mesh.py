import numpy as np

from fenics import *
from mshr import Polygon, generate_mesh


class Electrodes:
    """
    A class to represent the electrodes on a circular domain.

    Attributes
    ----------
    L : int
        Number of electrodes.
    per_cober : float
        Percentage of the boundary length covered by electrodes, between 0 and 1.
    rotation_angle : float, optional
        Rotation angle for the initial position of the electrodes (default is 0).
    anticlockwise : bool, optional
        Direction of rotation for electrode placement (default is True).
    position : list
        List of tuples representing the initial and final positions (in angles) of each electrode.
    """

    def __init__(self, L, per_cober, rotation_angle=0, *, anticlockwise=True):
        if not isinstance(L, int):
            raise TypeError("Number of electrodes (L) must be an int.")
        if not isinstance(per_cober, float):
            raise TypeError("`per_cober` must be a float.")
        if not isinstance(rotation_angle, (int, float)):
            raise TypeError("`rotation_angle` must be an int or float.")
        if not isinstance(anticlockwise, bool):
            raise TypeError("`anticlockwise` must be a boolean.")
        if per_cober > 1:
            raise ValueError(
                "`per_cober` must be less or equal to 1. Example (75%): per_cober=0.75"
            )

        self.L = L
        self.per_cober = per_cober
        self.rotation_angle = rotation_angle
        self.anticlockwise = anticlockwise
        self.position = self.__calc_position()

    def __calc_position(self):
        """
        Calculates and returns the positions of the electrodes.
        """
        size_e = 2 * np.pi / self.L * self.per_cober  # Size electrodes
        size_gap = 2 * np.pi / self.L * (1 - self.per_cober)  # Size gaps
        rotation_angle = self.rotation_angle  # Rotating original solution

        electrodes = [
            (
                size_e * i + size_gap * i + rotation_angle,
                size_e * (i + 1) + size_gap * i + rotation_angle,
            )  # Grouping angular values for electrodes.
            for i in range(self.L)
        ]

        if not self.anticlockwise:
            # Keep the first electrode and reverse the rest
            electrodes[1:] = electrodes[1:][::-1]

        return electrodes


def generate_electrodes_mesh(radius, resolution, N_in, N_out, electrodes):
    """
    Generate a mesh based on the positions of electrodes.

    This function creates a mesh for a circular domain with specified radius and
    refinement parameters. The mesh is generated based on the positions of electrodes
    and the number of vertices in the electrodes and gaps.

    Parameters
    ----------
    radius : float
        Radius of the circle.
    resolution : int
        Refinement parameter for mesh generation.
    N_in : int
        Number of vertices in each electrode.
    N_out : int
        Number of vertices in each gap between electrodes.
    electrodes : Electrodes
        Object containing the positions and properties of the electrodes.

    Returns
    -------
    dolfin.cpp.mesh.Mesh
        Generated mesh object.

    Notes
    -----
    The function assumes that the electrodes are positioned in an anticlockwise
    direction. If they are not, the function will reverse their order to ensure
    compatibility with the mesh generation process.
    """
    if not isinstance(radius, (int, float)):
        raise TypeError("`radius` must be an int or float.")
    if not isinstance(resolution, int):
        raise TypeError("`resolution` must be an int.")
    if not isinstance(N_in, int):
        raise TypeError("`N_in` must be an int.")
    if not isinstance(N_out, int):
        raise TypeError("`N_out` must be an int.")
    if not isinstance(electrodes, Electrodes):
        raise TypeError("`electrodes` must be generated by the Electrodes() class.")

    elec_pos = np.copy(electrodes.position)
    L = electrodes.L
    rotation_angle = electrodes.rotation_angle
    anticlockwise = electrodes.anticlockwise

    # Generating Points
    points = []
    vertices_elec = []
    if not anticlockwise:
        elec_pos[1:] = elec_pos[1:][::-1]  # Fenics only accepts anticlockwise
    for i in range(L):
        vertices = []
        # Creating vertex on the electrodes.
        theta0, thetai = elec_pos[i][0], elec_pos[i][1]
        for theta in np.linspace(theta0, thetai, N_in):
            pt = [
                Point((np.cos(theta) * radius, np.sin(theta) * radius))
            ]  # Defining Point object from Fenics.
            points.append(pt)  # Grouping points.

            vertex_coord = [
                np.cos(theta) * radius,
                np.sin(theta) * radius,
            ]  # Creating elec vertex on the boundary (anticlockwise)
            vertices.append(vertex_coord)  # Grouping vertices positions in R2

        # Selecting the last gap with the first electrode.
        if i < L - 1:
            theta0, thetai = elec_pos[i][1], elec_pos[i + 1][0]
        else:
            theta0, thetai = elec_pos[i][1], 2 * np.pi + rotation_angle

        # Creating vertex on the gaps.
        for theta in np.linspace(theta0, thetai, N_out + 2):
            if theta != theta0 and theta != thetai:
                pt = [
                    Point((np.cos(theta) * radius, np.sin(theta) * radius))
                ]  # Creating gap vertex on the boundary (anticlockwise)
                points.append(pt)  # Grouping points.

        vertices_elec.append(vertices)  # Grouping list of vertices in the electrode i

    if not anticlockwise:
        # Pass vertices in clockwise pattern
        # Keep the first electrode and reverse the rest
        vertices_elec[1:] = vertices_elec[1:][::-1]

    points = np.array(points).flatten()
    domain = Polygon(points)  # Creates a polygon with the points.
    dmesh = generate_mesh(domain, resolution)  # Generate the mesh.

    dmesh.radius = radius  # Pass the radius as attribute.
    dmesh.vertices_elec = (
        vertices_elec  # Pass the vertex position of the electrodes as attribute.
    )
    dmesh.electrodes = electrodes  # Pass the electrodes object as attribute.

    return dmesh


def print_mesh_config(dmesh):
    bmesh = BoundaryMesh(dmesh, "exterior", order=True)

    print("V  := Number of vertices (or nodes) in the mesh.")
    print(
        "VB := Number of vertices (or nodes) on the boundary of the mesh. (subset of V)"
    )
    print("N  := Number of cells (or elements) in the mesh.")
    print()
    print(
        "V: {}, VB: {}, N: {}".format(
            dmesh.num_vertices(), bmesh.num_vertices(), dmesh.num_cells()
        )
    )
    print("=" * 30)
